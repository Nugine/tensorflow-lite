/* tensorflow-lite v2.5.0 C API */
/* https://github.com/tensorflow/tensorflow/tree/v2.5.0/tensorflow/lite/c */
/* automatically generated by rust-bindgen 0.58.1 */

#[repr(C)]
#[derive(Default)]
pub struct __IncompleteArrayField<T>(::std::marker::PhantomData<T>, [T; 0]);
impl<T> __IncompleteArrayField<T> {
    #[inline]
    pub const fn new() -> Self {
        __IncompleteArrayField(::std::marker::PhantomData, [])
    }
    #[inline]
    pub fn as_ptr(&self) -> *const T {
        self as *const _ as *const T
    }
    #[inline]
    pub fn as_mut_ptr(&mut self) -> *mut T {
        self as *mut _ as *mut T
    }
    #[inline]
    pub unsafe fn as_slice(&self, len: usize) -> &[T] {
        ::std::slice::from_raw_parts(self.as_ptr(), len)
    }
    #[inline]
    pub unsafe fn as_mut_slice(&mut self, len: usize) -> &mut [T] {
        ::std::slice::from_raw_parts_mut(self.as_mut_ptr(), len)
    }
}
impl<T> ::std::fmt::Debug for __IncompleteArrayField<T> {
    fn fmt(&self, fmt: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        fmt.write_str("__IncompleteArrayField")
    }
}
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_long;
pub type __uint64_t = ::std::os::raw::c_ulong;
pub mod TfLiteStatus {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteOk: Type = 0;
    pub const kTfLiteError: Type = 1;
    pub const kTfLiteDelegateError: Type = 2;
    pub const kTfLiteApplicationError: Type = 3;
}
pub mod TfLiteType {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteNoType: Type = 0;
    pub const kTfLiteFloat32: Type = 1;
    pub const kTfLiteInt32: Type = 2;
    pub const kTfLiteUInt8: Type = 3;
    pub const kTfLiteInt64: Type = 4;
    pub const kTfLiteString: Type = 5;
    pub const kTfLiteBool: Type = 6;
    pub const kTfLiteInt16: Type = 7;
    pub const kTfLiteComplex64: Type = 8;
    pub const kTfLiteInt8: Type = 9;
    pub const kTfLiteFloat16: Type = 10;
    pub const kTfLiteFloat64: Type = 11;
    pub const kTfLiteComplex128: Type = 12;
    pub const kTfLiteUInt64: Type = 13;
    pub const kTfLiteResource: Type = 14;
    pub const kTfLiteVariant: Type = 15;
    pub const kTfLiteUInt32: Type = 16;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteQuantizationParams {
    pub scale: f32,
    pub zero_point: i32,
}
#[test]
fn bindgen_test_layout_TfLiteQuantizationParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteQuantizationParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteQuantizationParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteQuantizationParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteQuantizationParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteQuantizationParams>())).scale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantizationParams),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteQuantizationParams>())).zero_point as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantizationParams),
            "::",
            stringify!(zero_point)
        )
    );
}
pub mod TfLiteExternalContextType {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteEigenContext: Type = 0;
    pub const kTfLiteGemmLowpContext: Type = 1;
    pub const kTfLiteEdgeTpuContext: Type = 2;
    pub const kTfLiteCpuBackendContext: Type = 3;
    pub const kTfLiteMaxExternalContexts: Type = 4;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteExternalContext {
    pub type_: TfLiteExternalContextType::Type,
    pub Refresh: ::std::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext) -> TfLiteStatus::Type,
    >,
}
#[test]
fn bindgen_test_layout_TfLiteExternalContext() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteExternalContext>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteExternalContext))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteExternalContext>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteExternalContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteExternalContext>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteExternalContext),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteExternalContext>())).Refresh as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteExternalContext),
            "::",
            stringify!(Refresh)
        )
    );
}
#[repr(C)]
#[derive(Debug)]
pub struct TfLiteIntArray {
    pub size: ::std::os::raw::c_int,
    pub data: __IncompleteArrayField<::std::os::raw::c_int>,
}
#[test]
fn bindgen_test_layout_TfLiteIntArray() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteIntArray>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteIntArray))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteIntArray>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteIntArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteIntArray>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteIntArray),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteIntArray>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteIntArray),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn TfLiteIntArrayGetSizeInBytes(size: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TfLiteIntArrayCreate(size: ::std::os::raw::c_int) -> *mut TfLiteIntArray;
}
extern "C" {
    pub fn TfLiteIntArrayEqual(
        a: *const TfLiteIntArray,
        b: *const TfLiteIntArray,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TfLiteIntArrayEqualsArray(
        a: *const TfLiteIntArray,
        b_size: ::std::os::raw::c_int,
        b_data: *const ::std::os::raw::c_int,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TfLiteIntArrayCopy(src: *const TfLiteIntArray) -> *mut TfLiteIntArray;
}
extern "C" {
    pub fn TfLiteIntArrayFree(a: *mut TfLiteIntArray);
}
#[repr(C)]
#[derive(Debug)]
pub struct TfLiteFloatArray {
    pub size: ::std::os::raw::c_int,
    pub data: __IncompleteArrayField<f32>,
}
#[test]
fn bindgen_test_layout_TfLiteFloatArray() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteFloatArray>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteFloatArray))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteFloatArray>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteFloatArray))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteFloatArray>())).size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFloatArray),
            "::",
            stringify!(size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteFloatArray>())).data as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFloatArray),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn TfLiteFloatArrayGetSizeInBytes(size: ::std::os::raw::c_int) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn TfLiteFloatArrayCreate(size: ::std::os::raw::c_int) -> *mut TfLiteFloatArray;
}
extern "C" {
    pub fn TfLiteFloatArrayFree(a: *mut TfLiteFloatArray);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteComplex64 {
    pub re: f32,
    pub im: f32,
}
#[test]
fn bindgen_test_layout_TfLiteComplex64() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteComplex64>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteComplex64))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteComplex64>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteComplex64))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteComplex64>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex64),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteComplex64>())).im as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex64),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteComplex128 {
    pub re: f64,
    pub im: f64,
}
#[test]
fn bindgen_test_layout_TfLiteComplex128() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteComplex128>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteComplex128))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteComplex128>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteComplex128))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteComplex128>())).re as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex128),
            "::",
            stringify!(re)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteComplex128>())).im as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteComplex128),
            "::",
            stringify!(im)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteFloat16 {
    pub data: u16,
}
#[test]
fn bindgen_test_layout_TfLiteFloat16() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteFloat16>(),
        2usize,
        concat!("Size of: ", stringify!(TfLiteFloat16))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteFloat16>(),
        2usize,
        concat!("Alignment of ", stringify!(TfLiteFloat16))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteFloat16>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFloat16),
            "::",
            stringify!(data)
        )
    );
}
extern "C" {
    pub fn TfLiteTypeGetName(type_: TfLiteType::Type) -> *const ::std::os::raw::c_char;
}
pub mod TfLiteQuantizationType {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteNoQuantization: Type = 0;
    pub const kTfLiteAffineQuantization: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteQuantization {
    pub type_: TfLiteQuantizationType::Type,
    pub params: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_TfLiteQuantization() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteQuantization>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteQuantization))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteQuantization>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteQuantization))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteQuantization>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantization),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteQuantization>())).params as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteQuantization),
            "::",
            stringify!(params)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteAffineQuantization {
    pub scale: *mut TfLiteFloatArray,
    pub zero_point: *mut TfLiteIntArray,
    pub quantized_dimension: i32,
}
#[test]
fn bindgen_test_layout_TfLiteAffineQuantization() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteAffineQuantization>(),
        24usize,
        concat!("Size of: ", stringify!(TfLiteAffineQuantization))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteAffineQuantization>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteAffineQuantization))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteAffineQuantization>())).scale as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteAffineQuantization),
            "::",
            stringify!(scale)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteAffineQuantization>())).zero_point as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteAffineQuantization),
            "::",
            stringify!(zero_point)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteAffineQuantization>())).quantized_dimension as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteAffineQuantization),
            "::",
            stringify!(quantized_dimension)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub union TfLitePtrUnion {
    pub i32_: *mut i32,
    pub u32_: *mut u32,
    pub i64_: *mut i64,
    pub u64_: *mut u64,
    pub f: *mut f32,
    pub f16: *mut TfLiteFloat16,
    pub f64_: *mut f64,
    pub raw: *mut ::std::os::raw::c_char,
    pub raw_const: *const ::std::os::raw::c_char,
    pub uint8: *mut u8,
    pub b: *mut bool,
    pub i16_: *mut i16,
    pub c64: *mut TfLiteComplex64,
    pub c128: *mut TfLiteComplex128,
    pub int8: *mut i8,
    pub data: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout_TfLitePtrUnion() {
    assert_eq!(
        ::std::mem::size_of::<TfLitePtrUnion>(),
        8usize,
        concat!("Size of: ", stringify!(TfLitePtrUnion))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLitePtrUnion>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLitePtrUnion))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).i32_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(i32_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).u32_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(u32_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).i64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(i64_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).u64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(u64_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).f as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(f)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).f16 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(f16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).f64_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(f64_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).raw as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(raw)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).raw_const as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(raw_const)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).uint8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(uint8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).b as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(b)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).i16_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(i16_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).c64 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(c64)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).c128 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(c128)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).int8 as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(int8)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePtrUnion>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePtrUnion),
            "::",
            stringify!(data)
        )
    );
}
pub mod TfLiteAllocationType {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteMemNone: Type = 0;
    pub const kTfLiteMmapRo: Type = 1;
    pub const kTfLiteArenaRw: Type = 2;
    pub const kTfLiteArenaRwPersistent: Type = 3;
    pub const kTfLiteDynamic: Type = 4;
    pub const kTfLitePersistentRo: Type = 5;
    pub const kTfLiteCustom: Type = 6;
}
pub type TfLiteBufferHandle = ::std::os::raw::c_int;
pub mod TfLiteDimensionType {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteDimDense: Type = 0;
    pub const kTfLiteDimSparseCSR: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDimensionMetadata {
    pub format: TfLiteDimensionType::Type,
    pub dense_size: ::std::os::raw::c_int,
    pub array_segments: *mut TfLiteIntArray,
    pub array_indices: *mut TfLiteIntArray,
}
#[test]
fn bindgen_test_layout_TfLiteDimensionMetadata() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteDimensionMetadata>(),
        24usize,
        concat!("Size of: ", stringify!(TfLiteDimensionMetadata))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteDimensionMetadata>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteDimensionMetadata))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteDimensionMetadata>())).format as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDimensionMetadata>())).dense_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(dense_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDimensionMetadata>())).array_segments as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(array_segments)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDimensionMetadata>())).array_indices as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDimensionMetadata),
            "::",
            stringify!(array_indices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSparsity {
    pub traversal_order: *mut TfLiteIntArray,
    pub block_map: *mut TfLiteIntArray,
    pub dim_metadata: *mut TfLiteDimensionMetadata,
    pub dim_metadata_size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteSparsity() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSparsity>(),
        32usize,
        concat!("Size of: ", stringify!(TfLiteSparsity))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSparsity>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteSparsity))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSparsity>())).traversal_order as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(traversal_order)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSparsity>())).block_map as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(block_map)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSparsity>())).dim_metadata as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(dim_metadata)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSparsity>())).dim_metadata_size as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparsity),
            "::",
            stringify!(dim_metadata_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteCustomAllocation {
    pub data: *mut ::std::os::raw::c_void,
    pub bytes: usize,
}
#[test]
fn bindgen_test_layout_TfLiteCustomAllocation() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteCustomAllocation>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteCustomAllocation))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteCustomAllocation>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteCustomAllocation))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteCustomAllocation>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteCustomAllocation),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteCustomAllocation>())).bytes as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteCustomAllocation),
            "::",
            stringify!(bytes)
        )
    );
}
pub mod TfLiteCustomAllocationFlags {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteCustomAllocationFlagsNone: Type = 0;
    pub const kTfLiteCustomAllocationFlagsSkipAlignCheck: Type = 1;
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TfLiteTensor {
    pub type_: TfLiteType::Type,
    pub data: TfLitePtrUnion,
    pub dims: *mut TfLiteIntArray,
    pub params: TfLiteQuantizationParams,
    pub allocation_type: TfLiteAllocationType::Type,
    pub bytes: usize,
    pub allocation: *const ::std::os::raw::c_void,
    pub name: *const ::std::os::raw::c_char,
    pub delegate: *mut TfLiteDelegate,
    pub buffer_handle: TfLiteBufferHandle,
    pub data_is_stale: bool,
    pub is_variable: bool,
    pub quantization: TfLiteQuantization,
    pub sparsity: *mut TfLiteSparsity,
    pub dims_signature: *const TfLiteIntArray,
}
#[test]
fn bindgen_test_layout_TfLiteTensor() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteTensor>(),
        112usize,
        concat!("Size of: ", stringify!(TfLiteTensor))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteTensor>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteTensor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(type_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).data as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).dims as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).params as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(params)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).allocation_type as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(allocation_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).bytes as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(bytes)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).allocation as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(allocation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).name as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).delegate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(delegate)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).buffer_handle as *const _ as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(buffer_handle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).data_is_stale as *const _ as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(data_is_stale)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).is_variable as *const _ as usize },
        77usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(is_variable)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).quantization as *const _ as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(quantization)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).sparsity as *const _ as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(sparsity)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteTensor>())).dims_signature as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTensor),
            "::",
            stringify!(dims_signature)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteNode {
    pub inputs: *mut TfLiteIntArray,
    pub outputs: *mut TfLiteIntArray,
    pub intermediates: *mut TfLiteIntArray,
    pub temporaries: *mut TfLiteIntArray,
    pub user_data: *mut ::std::os::raw::c_void,
    pub builtin_data: *mut ::std::os::raw::c_void,
    pub custom_initial_data: *const ::std::os::raw::c_void,
    pub custom_initial_data_size: ::std::os::raw::c_int,
    pub delegate: *mut TfLiteDelegate,
}
#[test]
fn bindgen_test_layout_TfLiteNode() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteNode>(),
        72usize,
        concat!("Size of: ", stringify!(TfLiteNode))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteNode>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteNode))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteNode>())).inputs as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(inputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteNode>())).outputs as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(outputs)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteNode>())).intermediates as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(intermediates)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteNode>())).temporaries as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(temporaries)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteNode>())).user_data as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(user_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteNode>())).builtin_data as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(builtin_data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteNode>())).custom_initial_data as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(custom_initial_data)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteNode>())).custom_initial_data_size as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(custom_initial_data_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteNode>())).delegate as *const _ as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteNode),
            "::",
            stringify!(delegate)
        )
    );
}
#[repr(C)]
#[derive(Copy, Clone)]
pub struct TfLiteEvalTensor {
    pub data: TfLitePtrUnion,
    pub dims: *mut TfLiteIntArray,
    pub type_: TfLiteType::Type,
}
#[test]
fn bindgen_test_layout_TfLiteEvalTensor() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteEvalTensor>(),
        24usize,
        concat!("Size of: ", stringify!(TfLiteEvalTensor))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteEvalTensor>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteEvalTensor))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteEvalTensor>())).data as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteEvalTensor),
            "::",
            stringify!(data)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteEvalTensor>())).dims as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteEvalTensor),
            "::",
            stringify!(dims)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteEvalTensor>())).type_ as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteEvalTensor),
            "::",
            stringify!(type_)
        )
    );
}
extern "C" {
    pub fn TfLiteTensorDataFree(t: *mut TfLiteTensor);
}
extern "C" {
    pub fn TfLiteQuantizationFree(quantization: *mut TfLiteQuantization);
}
extern "C" {
    pub fn TfLiteSparsityFree(sparsity: *mut TfLiteSparsity);
}
extern "C" {
    pub fn TfLiteTensorFree(t: *mut TfLiteTensor);
}
extern "C" {
    pub fn TfLiteTensorReset(
        type_: TfLiteType::Type,
        name: *const ::std::os::raw::c_char,
        dims: *mut TfLiteIntArray,
        quantization: TfLiteQuantizationParams,
        buffer: *mut ::std::os::raw::c_char,
        size: usize,
        allocation_type: TfLiteAllocationType::Type,
        allocation: *const ::std::os::raw::c_void,
        is_variable: bool,
        tensor: *mut TfLiteTensor,
    );
}
extern "C" {
    pub fn TfLiteTensorRealloc(num_bytes: usize, tensor: *mut TfLiteTensor);
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDelegateParams {
    pub delegate: *mut TfLiteDelegate,
    pub nodes_to_replace: *mut TfLiteIntArray,
    pub input_tensors: *mut TfLiteIntArray,
    pub output_tensors: *mut TfLiteIntArray,
}
#[test]
fn bindgen_test_layout_TfLiteDelegateParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteDelegateParams>(),
        32usize,
        concat!("Size of: ", stringify!(TfLiteDelegateParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteDelegateParams>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteDelegateParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteDelegateParams>())).delegate as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(delegate)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDelegateParams>())).nodes_to_replace as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(nodes_to_replace)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDelegateParams>())).input_tensors as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(input_tensors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDelegateParams>())).output_tensors as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegateParams),
            "::",
            stringify!(output_tensors)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteContext {
    pub tensors_size: usize,
    pub GetExecutionPlan: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            execution_plan: *mut *mut TfLiteIntArray,
        ) -> TfLiteStatus::Type,
    >,
    pub tensors: *mut TfLiteTensor,
    pub impl_: *mut ::std::os::raw::c_void,
    pub ResizeTensor: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            tensor: *mut TfLiteTensor,
            new_size: *mut TfLiteIntArray,
        ) -> TfLiteStatus::Type,
    >,
    pub ReportError: ::std::option::Option<
        unsafe extern "C" fn(arg1: *mut TfLiteContext, msg: *const ::std::os::raw::c_char, ...),
    >,
    pub AddTensors: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            tensors_to_add: ::std::os::raw::c_int,
            first_new_tensor_index: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus::Type,
    >,
    pub GetNodeAndRegistration: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            node_index: ::std::os::raw::c_int,
            node: *mut *mut TfLiteNode,
            registration: *mut *mut TfLiteRegistration,
        ) -> TfLiteStatus::Type,
    >,
    pub ReplaceNodeSubsetsWithDelegateKernels: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            registration: TfLiteRegistration,
            nodes_to_replace: *const TfLiteIntArray,
            delegate: *mut TfLiteDelegate,
        ) -> TfLiteStatus::Type,
    >,
    pub recommended_num_threads: ::std::os::raw::c_int,
    pub GetExternalContext: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            arg2: TfLiteExternalContextType::Type,
        ) -> *mut TfLiteExternalContext,
    >,
    pub SetExternalContext: ::std::option::Option<
        unsafe extern "C" fn(
            arg1: *mut TfLiteContext,
            arg2: TfLiteExternalContextType::Type,
            arg3: *mut TfLiteExternalContext,
        ),
    >,
    pub allow_fp32_relax_to_fp16: bool,
    pub profiler: *mut ::std::os::raw::c_void,
    pub AllocatePersistentBuffer: ::std::option::Option<
        unsafe extern "C" fn(ctx: *mut TfLiteContext, bytes: usize) -> *mut ::std::os::raw::c_void,
    >,
    pub AllocateBufferForEval: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            bytes: usize,
            ptr: *mut *mut ::std::os::raw::c_void,
        ) -> TfLiteStatus::Type,
    >,
    pub RequestScratchBufferInArena: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            bytes: usize,
            buffer_idx: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus::Type,
    >,
    pub GetScratchBuffer: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            buffer_idx: ::std::os::raw::c_int,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub ResizeTensorExplicit: ::std::option::Option<
        unsafe extern "C" fn(
            ctx: *mut TfLiteContext,
            tensor: *mut TfLiteTensor,
            dims: ::std::os::raw::c_int,
            shape: *const ::std::os::raw::c_int,
        ) -> TfLiteStatus::Type,
    >,
    pub PreviewDelegatePartitioning: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            nodes_to_replace: *const TfLiteIntArray,
            partition_params_array: *mut *mut TfLiteDelegateParams,
            num_partitions: *mut ::std::os::raw::c_int,
        ) -> TfLiteStatus::Type,
    >,
    pub GetTensor: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            tensor_idx: ::std::os::raw::c_int,
        ) -> *mut TfLiteTensor,
    >,
    pub GetEvalTensor: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            tensor_idx: ::std::os::raw::c_int,
        ) -> *mut TfLiteEvalTensor,
    >,
}
#[test]
fn bindgen_test_layout_TfLiteContext() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteContext>(),
        176usize,
        concat!("Size of: ", stringify!(TfLiteContext))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteContext>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteContext))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).tensors_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(tensors_size)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).GetExecutionPlan as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetExecutionPlan)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).tensors as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(tensors)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).impl_ as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(impl_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).ResizeTensor as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ResizeTensor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).ReportError as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ReportError)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).AddTensors as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AddTensors)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).GetNodeAndRegistration as *const _ as usize
        },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetNodeAndRegistration)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).ReplaceNodeSubsetsWithDelegateKernels
                as *const _ as usize
        },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ReplaceNodeSubsetsWithDelegateKernels)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).recommended_num_threads as *const _ as usize
        },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(recommended_num_threads)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).GetExternalContext as *const _ as usize
        },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetExternalContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).SetExternalContext as *const _ as usize
        },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(SetExternalContext)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).allow_fp32_relax_to_fp16 as *const _ as usize
        },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(allow_fp32_relax_to_fp16)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).profiler as *const _ as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(profiler)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).AllocatePersistentBuffer as *const _ as usize
        },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AllocatePersistentBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).AllocateBufferForEval as *const _ as usize
        },
        120usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(AllocateBufferForEval)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).RequestScratchBufferInArena as *const _
                as usize
        },
        128usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(RequestScratchBufferInArena)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).GetScratchBuffer as *const _ as usize },
        136usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetScratchBuffer)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).ResizeTensorExplicit as *const _ as usize
        },
        144usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(ResizeTensorExplicit)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteContext>())).PreviewDelegatePartitioning as *const _
                as usize
        },
        152usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(PreviewDelegatePartitioning)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).GetTensor as *const _ as usize },
        160usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetTensor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteContext>())).GetEvalTensor as *const _ as usize },
        168usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteContext),
            "::",
            stringify!(GetEvalTensor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteRegistration {
    pub init: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            buffer: *const ::std::os::raw::c_char,
            length: usize,
        ) -> *mut ::std::os::raw::c_void,
    >,
    pub free: ::std::option::Option<
        unsafe extern "C" fn(context: *mut TfLiteContext, buffer: *mut ::std::os::raw::c_void),
    >,
    pub prepare: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            node: *mut TfLiteNode,
        ) -> TfLiteStatus::Type,
    >,
    pub invoke: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            node: *mut TfLiteNode,
        ) -> TfLiteStatus::Type,
    >,
    pub profiling_string: ::std::option::Option<
        unsafe extern "C" fn(
            context: *const TfLiteContext,
            node: *const TfLiteNode,
        ) -> *const ::std::os::raw::c_char,
    >,
    pub builtin_code: i32,
    pub custom_name: *const ::std::os::raw::c_char,
    pub version: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteRegistration() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteRegistration>(),
        64usize,
        concat!("Size of: ", stringify!(TfLiteRegistration))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteRegistration>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteRegistration))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteRegistration>())).init as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(init)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteRegistration>())).free as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(free)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteRegistration>())).prepare as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(prepare)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteRegistration>())).invoke as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(invoke)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteRegistration>())).profiling_string as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(profiling_string)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteRegistration>())).builtin_code as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(builtin_code)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteRegistration>())).custom_name as *const _ as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(custom_name)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteRegistration>())).version as *const _ as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRegistration),
            "::",
            stringify!(version)
        )
    );
}
pub mod TfLiteDelegateFlags {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteDelegateFlagsNone: Type = 0;
    pub const kTfLiteDelegateFlagsAllowDynamicTensors: Type = 1;
    pub const kTfLiteDelegateFlagsRequirePropagatedShapes: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDelegate {
    pub data_: *mut ::std::os::raw::c_void,
    pub Prepare: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
        ) -> TfLiteStatus::Type,
    >,
    pub CopyFromBufferHandle: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
            buffer_handle: TfLiteBufferHandle,
            tensor: *mut TfLiteTensor,
        ) -> TfLiteStatus::Type,
    >,
    pub CopyToBufferHandle: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
            buffer_handle: TfLiteBufferHandle,
            tensor: *mut TfLiteTensor,
        ) -> TfLiteStatus::Type,
    >,
    pub FreeBufferHandle: ::std::option::Option<
        unsafe extern "C" fn(
            context: *mut TfLiteContext,
            delegate: *mut TfLiteDelegate,
            handle: *mut TfLiteBufferHandle,
        ),
    >,
    pub flags: i64,
}
#[test]
fn bindgen_test_layout_TfLiteDelegate() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteDelegate>(),
        48usize,
        concat!("Size of: ", stringify!(TfLiteDelegate))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteDelegate>(),
        8usize,
        concat!("Alignment of ", stringify!(TfLiteDelegate))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteDelegate>())).data_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(data_)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteDelegate>())).Prepare as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(Prepare)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDelegate>())).CopyFromBufferHandle as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(CopyFromBufferHandle)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDelegate>())).CopyToBufferHandle as *const _ as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(CopyToBufferHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteDelegate>())).FreeBufferHandle as *const _ as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(FreeBufferHandle)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteDelegate>())).flags as *const _ as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDelegate),
            "::",
            stringify!(flags)
        )
    );
}
extern "C" {
    pub fn TfLiteDelegateCreate() -> TfLiteDelegate;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct EmptyStructPlaceholder {
    pub dummy: ::std::os::raw::c_char,
}
#[test]
fn bindgen_test_layout_EmptyStructPlaceholder() {
    assert_eq!(
        ::std::mem::size_of::<EmptyStructPlaceholder>(),
        1usize,
        concat!("Size of: ", stringify!(EmptyStructPlaceholder))
    );
    assert_eq!(
        ::std::mem::align_of::<EmptyStructPlaceholder>(),
        1usize,
        concat!("Alignment of ", stringify!(EmptyStructPlaceholder))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<EmptyStructPlaceholder>())).dummy as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(EmptyStructPlaceholder),
            "::",
            stringify!(dummy)
        )
    );
}
pub mod TfLitePadding {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLitePaddingUnknown: Type = 0;
    pub const kTfLitePaddingSame: Type = 1;
    pub const kTfLitePaddingValid: Type = 2;
}
pub mod TfLiteMirrorPaddingMode {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteMirrorPaddingUnknown: Type = 0;
    pub const kTfLiteMirrorPaddingReflect: Type = 1;
    pub const kTfLiteMirrorPaddingSymmetric: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLitePaddingValues {
    pub width: ::std::os::raw::c_int,
    pub height: ::std::os::raw::c_int,
    pub width_offset: ::std::os::raw::c_int,
    pub height_offset: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLitePaddingValues() {
    assert_eq!(
        ::std::mem::size_of::<TfLitePaddingValues>(),
        16usize,
        concat!("Size of: ", stringify!(TfLitePaddingValues))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLitePaddingValues>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLitePaddingValues))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePaddingValues>())).width as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePaddingValues),
            "::",
            stringify!(width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePaddingValues>())).height as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePaddingValues),
            "::",
            stringify!(height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLitePaddingValues>())).width_offset as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePaddingValues),
            "::",
            stringify!(width_offset)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLitePaddingValues>())).height_offset as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePaddingValues),
            "::",
            stringify!(height_offset)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteMirrorPaddingParams {
    pub mode: TfLiteMirrorPaddingMode::Type,
}
#[test]
fn bindgen_test_layout_TfLiteMirrorPaddingParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteMirrorPaddingParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteMirrorPaddingParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteMirrorPaddingParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteMirrorPaddingParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteMirrorPaddingParams>())).mode as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteMirrorPaddingParams),
            "::",
            stringify!(mode)
        )
    );
}
pub mod TfLiteFusedActivation {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteActNone: Type = 0;
    pub const kTfLiteActRelu: Type = 1;
    pub const kTfLiteActReluN1To1: Type = 2;
    pub const kTfLiteActRelu6: Type = 3;
    pub const kTfLiteActTanh: Type = 4;
    pub const kTfLiteActSignBit: Type = 5;
    pub const kTfLiteActSigmoid: Type = 6;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteConvParams {
    pub padding: TfLitePadding::Type,
    pub stride_width: ::std::os::raw::c_int,
    pub stride_height: ::std::os::raw::c_int,
    pub activation: TfLiteFusedActivation::Type,
    pub dilation_width_factor: ::std::os::raw::c_int,
    pub dilation_height_factor: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteConvParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteConvParams>(),
        24usize,
        concat!("Size of: ", stringify!(TfLiteConvParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteConvParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteConvParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteConvParams>())).padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConvParams),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteConvParams>())).stride_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConvParams),
            "::",
            stringify!(stride_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteConvParams>())).stride_height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConvParams),
            "::",
            stringify!(stride_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteConvParams>())).activation as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConvParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteConvParams>())).dilation_width_factor as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConvParams),
            "::",
            stringify!(dilation_width_factor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteConvParams>())).dilation_height_factor as *const _ as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConvParams),
            "::",
            stringify!(dilation_height_factor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteConv3DParams {
    pub padding: TfLitePadding::Type,
    pub stride_width: ::std::os::raw::c_int,
    pub stride_height: ::std::os::raw::c_int,
    pub stride_depth: ::std::os::raw::c_int,
    pub dilation_width_factor: ::std::os::raw::c_int,
    pub dilation_height_factor: ::std::os::raw::c_int,
    pub dilation_depth_factor: ::std::os::raw::c_int,
    pub activation: TfLiteFusedActivation::Type,
}
#[test]
fn bindgen_test_layout_TfLiteConv3DParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteConv3DParams>(),
        32usize,
        concat!("Size of: ", stringify!(TfLiteConv3DParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteConv3DParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteConv3DParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteConv3DParams>())).padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConv3DParams),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteConv3DParams>())).stride_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConv3DParams),
            "::",
            stringify!(stride_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteConv3DParams>())).stride_height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConv3DParams),
            "::",
            stringify!(stride_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteConv3DParams>())).stride_depth as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConv3DParams),
            "::",
            stringify!(stride_depth)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteConv3DParams>())).dilation_width_factor as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConv3DParams),
            "::",
            stringify!(dilation_width_factor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteConv3DParams>())).dilation_height_factor as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConv3DParams),
            "::",
            stringify!(dilation_height_factor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteConv3DParams>())).dilation_depth_factor as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConv3DParams),
            "::",
            stringify!(dilation_depth_factor)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteConv3DParams>())).activation as *const _ as usize },
        28usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConv3DParams),
            "::",
            stringify!(activation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLitePoolParams {
    pub padding: TfLitePadding::Type,
    pub stride_width: ::std::os::raw::c_int,
    pub stride_height: ::std::os::raw::c_int,
    pub filter_width: ::std::os::raw::c_int,
    pub filter_height: ::std::os::raw::c_int,
    pub activation: TfLiteFusedActivation::Type,
    pub computed: TfLitePoolParams__bindgen_ty_1,
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLitePoolParams__bindgen_ty_1 {
    pub padding: TfLitePaddingValues,
}
#[test]
fn bindgen_test_layout_TfLitePoolParams__bindgen_ty_1() {
    assert_eq!(
        ::std::mem::size_of::<TfLitePoolParams__bindgen_ty_1>(),
        16usize,
        concat!("Size of: ", stringify!(TfLitePoolParams__bindgen_ty_1))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLitePoolParams__bindgen_ty_1>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLitePoolParams__bindgen_ty_1))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLitePoolParams__bindgen_ty_1>())).padding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePoolParams__bindgen_ty_1),
            "::",
            stringify!(padding)
        )
    );
}
#[test]
fn bindgen_test_layout_TfLitePoolParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLitePoolParams>(),
        40usize,
        concat!("Size of: ", stringify!(TfLitePoolParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLitePoolParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLitePoolParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePoolParams>())).padding as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePoolParams),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePoolParams>())).stride_width as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePoolParams),
            "::",
            stringify!(stride_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePoolParams>())).stride_height as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePoolParams),
            "::",
            stringify!(stride_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePoolParams>())).filter_width as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePoolParams),
            "::",
            stringify!(filter_width)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePoolParams>())).filter_height as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePoolParams),
            "::",
            stringify!(filter_height)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePoolParams>())).activation as *const _ as usize },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePoolParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePoolParams>())).computed as *const _ as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePoolParams),
            "::",
            stringify!(computed)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDepthwiseConvParams {
    pub padding: TfLitePadding::Type,
    pub stride_width: ::std::os::raw::c_int,
    pub stride_height: ::std::os::raw::c_int,
    pub depth_multiplier: ::std::os::raw::c_int,
    pub activation: TfLiteFusedActivation::Type,
    pub dilation_width_factor: ::std::os::raw::c_int,
    pub dilation_height_factor: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteDepthwiseConvParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteDepthwiseConvParams>(),
        28usize,
        concat!("Size of: ", stringify!(TfLiteDepthwiseConvParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteDepthwiseConvParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteDepthwiseConvParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDepthwiseConvParams>())).padding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDepthwiseConvParams),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDepthwiseConvParams>())).stride_width as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDepthwiseConvParams),
            "::",
            stringify!(stride_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDepthwiseConvParams>())).stride_height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDepthwiseConvParams),
            "::",
            stringify!(stride_height)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDepthwiseConvParams>())).depth_multiplier as *const _
                as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDepthwiseConvParams),
            "::",
            stringify!(depth_multiplier)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDepthwiseConvParams>())).activation as *const _ as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDepthwiseConvParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDepthwiseConvParams>())).dilation_width_factor as *const _
                as usize
        },
        20usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDepthwiseConvParams),
            "::",
            stringify!(dilation_width_factor)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDepthwiseConvParams>())).dilation_height_factor as *const _
                as usize
        },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDepthwiseConvParams),
            "::",
            stringify!(dilation_height_factor)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSVDFParams {
    pub rank: ::std::os::raw::c_int,
    pub activation: TfLiteFusedActivation::Type,
    pub asymmetric_quantize_inputs: bool,
}
#[test]
fn bindgen_test_layout_TfLiteSVDFParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSVDFParams>(),
        12usize,
        concat!("Size of: ", stringify!(TfLiteSVDFParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSVDFParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteSVDFParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSVDFParams>())).rank as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSVDFParams),
            "::",
            stringify!(rank)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSVDFParams>())).activation as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSVDFParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSVDFParams>())).asymmetric_quantize_inputs as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSVDFParams),
            "::",
            stringify!(asymmetric_quantize_inputs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteRNNParams {
    pub activation: TfLiteFusedActivation::Type,
    pub asymmetric_quantize_inputs: bool,
}
#[test]
fn bindgen_test_layout_TfLiteRNNParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteRNNParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteRNNParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteRNNParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteRNNParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteRNNParams>())).activation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRNNParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteRNNParams>())).asymmetric_quantize_inputs as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRNNParams),
            "::",
            stringify!(asymmetric_quantize_inputs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSequenceRNNParams {
    pub time_major: bool,
    pub activation: TfLiteFusedActivation::Type,
    pub asymmetric_quantize_inputs: bool,
}
#[test]
fn bindgen_test_layout_TfLiteSequenceRNNParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSequenceRNNParams>(),
        12usize,
        concat!("Size of: ", stringify!(TfLiteSequenceRNNParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSequenceRNNParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteSequenceRNNParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSequenceRNNParams>())).time_major as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSequenceRNNParams),
            "::",
            stringify!(time_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSequenceRNNParams>())).activation as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSequenceRNNParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSequenceRNNParams>())).asymmetric_quantize_inputs
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSequenceRNNParams),
            "::",
            stringify!(asymmetric_quantize_inputs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteBidirectionalSequenceRNNParams {
    pub time_major: bool,
    pub activation: TfLiteFusedActivation::Type,
    pub merge_outputs: bool,
    pub asymmetric_quantize_inputs: bool,
}
#[test]
fn bindgen_test_layout_TfLiteBidirectionalSequenceRNNParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteBidirectionalSequenceRNNParams>(),
        12usize,
        concat!(
            "Size of: ",
            stringify!(TfLiteBidirectionalSequenceRNNParams)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteBidirectionalSequenceRNNParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(TfLiteBidirectionalSequenceRNNParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBidirectionalSequenceRNNParams>())).time_major as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBidirectionalSequenceRNNParams),
            "::",
            stringify!(time_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBidirectionalSequenceRNNParams>())).activation as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBidirectionalSequenceRNNParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBidirectionalSequenceRNNParams>())).merge_outputs
                as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBidirectionalSequenceRNNParams),
            "::",
            stringify!(merge_outputs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBidirectionalSequenceRNNParams>()))
                .asymmetric_quantize_inputs as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBidirectionalSequenceRNNParams),
            "::",
            stringify!(asymmetric_quantize_inputs)
        )
    );
}
pub mod TfLiteFullyConnectedWeightsFormat {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteFullyConnectedWeightsFormatDefault: Type = 0;
    pub const kTfLiteFullyConnectedWeightsFormatShuffled4x16Int8: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteFullyConnectedParams {
    pub activation: TfLiteFusedActivation::Type,
    pub weights_format: TfLiteFullyConnectedWeightsFormat::Type,
    pub keep_num_dims: bool,
    pub asymmetric_quantize_inputs: bool,
}
#[test]
fn bindgen_test_layout_TfLiteFullyConnectedParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteFullyConnectedParams>(),
        12usize,
        concat!("Size of: ", stringify!(TfLiteFullyConnectedParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteFullyConnectedParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteFullyConnectedParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteFullyConnectedParams>())).activation as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFullyConnectedParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteFullyConnectedParams>())).weights_format as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFullyConnectedParams),
            "::",
            stringify!(weights_format)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteFullyConnectedParams>())).keep_num_dims as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFullyConnectedParams),
            "::",
            stringify!(keep_num_dims)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteFullyConnectedParams>())).asymmetric_quantize_inputs
                as *const _ as usize
        },
        9usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFullyConnectedParams),
            "::",
            stringify!(asymmetric_quantize_inputs)
        )
    );
}
pub mod TfLiteLSHProjectionType {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteLshProjectionUnknown: Type = 0;
    pub const kTfLiteLshProjectionSparse: Type = 1;
    pub const kTfLiteLshProjectionDense: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteLSHProjectionParams {
    pub type_: TfLiteLSHProjectionType::Type,
}
#[test]
fn bindgen_test_layout_TfLiteLSHProjectionParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteLSHProjectionParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteLSHProjectionParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteLSHProjectionParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteLSHProjectionParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteLSHProjectionParams>())).type_ as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLSHProjectionParams),
            "::",
            stringify!(type_)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSoftmaxParams {
    pub beta: f32,
}
#[test]
fn bindgen_test_layout_TfLiteSoftmaxParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSoftmaxParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteSoftmaxParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSoftmaxParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteSoftmaxParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSoftmaxParams>())).beta as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSoftmaxParams),
            "::",
            stringify!(beta)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteConcatenationParams {
    pub axis: ::std::os::raw::c_int,
    pub activation: TfLiteFusedActivation::Type,
}
#[test]
fn bindgen_test_layout_TfLiteConcatenationParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteConcatenationParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteConcatenationParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteConcatenationParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteConcatenationParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteConcatenationParams>())).axis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConcatenationParams),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteConcatenationParams>())).activation as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteConcatenationParams),
            "::",
            stringify!(activation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteAddParams {
    pub activation: TfLiteFusedActivation::Type,
    pub pot_scale_int16: bool,
}
#[test]
fn bindgen_test_layout_TfLiteAddParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteAddParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteAddParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteAddParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteAddParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteAddParams>())).activation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteAddParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteAddParams>())).pot_scale_int16 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteAddParams),
            "::",
            stringify!(pot_scale_int16)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSpaceToBatchNDParams {
    pub placeholder: EmptyStructPlaceholder,
}
#[test]
fn bindgen_test_layout_TfLiteSpaceToBatchNDParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSpaceToBatchNDParams>(),
        1usize,
        concat!("Size of: ", stringify!(TfLiteSpaceToBatchNDParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSpaceToBatchNDParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteSpaceToBatchNDParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSpaceToBatchNDParams>())).placeholder as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSpaceToBatchNDParams),
            "::",
            stringify!(placeholder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteBatchToSpaceNDParams {
    pub placeholder: EmptyStructPlaceholder,
}
#[test]
fn bindgen_test_layout_TfLiteBatchToSpaceNDParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteBatchToSpaceNDParams>(),
        1usize,
        concat!("Size of: ", stringify!(TfLiteBatchToSpaceNDParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteBatchToSpaceNDParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteBatchToSpaceNDParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBatchToSpaceNDParams>())).placeholder as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBatchToSpaceNDParams),
            "::",
            stringify!(placeholder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteBatchMatMulParams {
    pub adj_x: bool,
    pub adj_y: bool,
    pub asymmetric_quantize_inputs: bool,
}
#[test]
fn bindgen_test_layout_TfLiteBatchMatMulParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteBatchMatMulParams>(),
        3usize,
        concat!("Size of: ", stringify!(TfLiteBatchMatMulParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteBatchMatMulParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteBatchMatMulParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteBatchMatMulParams>())).adj_x as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBatchMatMulParams),
            "::",
            stringify!(adj_x)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteBatchMatMulParams>())).adj_y as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBatchMatMulParams),
            "::",
            stringify!(adj_y)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBatchMatMulParams>())).asymmetric_quantize_inputs
                as *const _ as usize
        },
        2usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBatchMatMulParams),
            "::",
            stringify!(asymmetric_quantize_inputs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteMulParams {
    pub activation: TfLiteFusedActivation::Type,
}
#[test]
fn bindgen_test_layout_TfLiteMulParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteMulParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteMulParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteMulParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteMulParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteMulParams>())).activation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteMulParams),
            "::",
            stringify!(activation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSubParams {
    pub activation: TfLiteFusedActivation::Type,
    pub pot_scale_int16: bool,
}
#[test]
fn bindgen_test_layout_TfLiteSubParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSubParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteSubParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSubParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteSubParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSubParams>())).activation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSubParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSubParams>())).pot_scale_int16 as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSubParams),
            "::",
            stringify!(pot_scale_int16)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDivParams {
    pub activation: TfLiteFusedActivation::Type,
}
#[test]
fn bindgen_test_layout_TfLiteDivParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteDivParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteDivParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteDivParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteDivParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteDivParams>())).activation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDivParams),
            "::",
            stringify!(activation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteL2NormParams {
    pub activation: TfLiteFusedActivation::Type,
}
#[test]
fn bindgen_test_layout_TfLiteL2NormParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteL2NormParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteL2NormParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteL2NormParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteL2NormParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteL2NormParams>())).activation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteL2NormParams),
            "::",
            stringify!(activation)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteLocalResponseNormParams {
    pub radius: ::std::os::raw::c_int,
    pub bias: f32,
    pub alpha: f32,
    pub beta: f32,
}
#[test]
fn bindgen_test_layout_TfLiteLocalResponseNormParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteLocalResponseNormParams>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteLocalResponseNormParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteLocalResponseNormParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteLocalResponseNormParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteLocalResponseNormParams>())).radius as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLocalResponseNormParams),
            "::",
            stringify!(radius)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteLocalResponseNormParams>())).bias as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLocalResponseNormParams),
            "::",
            stringify!(bias)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteLocalResponseNormParams>())).alpha as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLocalResponseNormParams),
            "::",
            stringify!(alpha)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteLocalResponseNormParams>())).beta as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLocalResponseNormParams),
            "::",
            stringify!(beta)
        )
    );
}
pub mod TfLiteLSTMKernelType {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteLSTMFullKernel: Type = 0;
    pub const kTfLiteLSTMBasicKernel: Type = 1;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteLSTMParams {
    pub activation: TfLiteFusedActivation::Type,
    pub cell_clip: f32,
    pub proj_clip: f32,
    pub kernel_type: TfLiteLSTMKernelType::Type,
    pub asymmetric_quantize_inputs: bool,
}
#[test]
fn bindgen_test_layout_TfLiteLSTMParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteLSTMParams>(),
        20usize,
        concat!("Size of: ", stringify!(TfLiteLSTMParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteLSTMParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteLSTMParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteLSTMParams>())).activation as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLSTMParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteLSTMParams>())).cell_clip as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLSTMParams),
            "::",
            stringify!(cell_clip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteLSTMParams>())).proj_clip as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLSTMParams),
            "::",
            stringify!(proj_clip)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteLSTMParams>())).kernel_type as *const _ as usize },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLSTMParams),
            "::",
            stringify!(kernel_type)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteLSTMParams>())).asymmetric_quantize_inputs as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLSTMParams),
            "::",
            stringify!(asymmetric_quantize_inputs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteUnidirectionalSequenceLSTMParams {
    pub activation: TfLiteFusedActivation::Type,
    pub cell_clip: f32,
    pub proj_clip: f32,
    pub time_major: bool,
    pub asymmetric_quantize_inputs: bool,
}
#[test]
fn bindgen_test_layout_TfLiteUnidirectionalSequenceLSTMParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteUnidirectionalSequenceLSTMParams>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(TfLiteUnidirectionalSequenceLSTMParams)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteUnidirectionalSequenceLSTMParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(TfLiteUnidirectionalSequenceLSTMParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteUnidirectionalSequenceLSTMParams>())).activation
                as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteUnidirectionalSequenceLSTMParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteUnidirectionalSequenceLSTMParams>())).cell_clip as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteUnidirectionalSequenceLSTMParams),
            "::",
            stringify!(cell_clip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteUnidirectionalSequenceLSTMParams>())).proj_clip as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteUnidirectionalSequenceLSTMParams),
            "::",
            stringify!(proj_clip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteUnidirectionalSequenceLSTMParams>())).time_major
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteUnidirectionalSequenceLSTMParams),
            "::",
            stringify!(time_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteUnidirectionalSequenceLSTMParams>()))
                .asymmetric_quantize_inputs as *const _ as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteUnidirectionalSequenceLSTMParams),
            "::",
            stringify!(asymmetric_quantize_inputs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteBidirectionalSequenceLSTMParams {
    pub activation: TfLiteFusedActivation::Type,
    pub cell_clip: f32,
    pub proj_clip: f32,
    pub merge_outputs: bool,
    pub time_major: bool,
    pub asymmetric_quantize_inputs: bool,
}
#[test]
fn bindgen_test_layout_TfLiteBidirectionalSequenceLSTMParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteBidirectionalSequenceLSTMParams>(),
        16usize,
        concat!(
            "Size of: ",
            stringify!(TfLiteBidirectionalSequenceLSTMParams)
        )
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteBidirectionalSequenceLSTMParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(TfLiteBidirectionalSequenceLSTMParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBidirectionalSequenceLSTMParams>())).activation as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBidirectionalSequenceLSTMParams),
            "::",
            stringify!(activation)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBidirectionalSequenceLSTMParams>())).cell_clip as *const _
                as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBidirectionalSequenceLSTMParams),
            "::",
            stringify!(cell_clip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBidirectionalSequenceLSTMParams>())).proj_clip as *const _
                as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBidirectionalSequenceLSTMParams),
            "::",
            stringify!(proj_clip)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBidirectionalSequenceLSTMParams>())).merge_outputs
                as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBidirectionalSequenceLSTMParams),
            "::",
            stringify!(merge_outputs)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBidirectionalSequenceLSTMParams>())).time_major as *const _
                as usize
        },
        13usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBidirectionalSequenceLSTMParams),
            "::",
            stringify!(time_major)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteBidirectionalSequenceLSTMParams>()))
                .asymmetric_quantize_inputs as *const _ as usize
        },
        14usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteBidirectionalSequenceLSTMParams),
            "::",
            stringify!(asymmetric_quantize_inputs)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteResizeBilinearParams {
    pub align_corners: bool,
    pub half_pixel_centers: bool,
}
#[test]
fn bindgen_test_layout_TfLiteResizeBilinearParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteResizeBilinearParams>(),
        2usize,
        concat!("Size of: ", stringify!(TfLiteResizeBilinearParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteResizeBilinearParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteResizeBilinearParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteResizeBilinearParams>())).align_corners as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteResizeBilinearParams),
            "::",
            stringify!(align_corners)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteResizeBilinearParams>())).half_pixel_centers as *const _
                as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteResizeBilinearParams),
            "::",
            stringify!(half_pixel_centers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteResizeNearestNeighborParams {
    pub align_corners: bool,
    pub half_pixel_centers: bool,
}
#[test]
fn bindgen_test_layout_TfLiteResizeNearestNeighborParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteResizeNearestNeighborParams>(),
        2usize,
        concat!("Size of: ", stringify!(TfLiteResizeNearestNeighborParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteResizeNearestNeighborParams>(),
        1usize,
        concat!(
            "Alignment of ",
            stringify!(TfLiteResizeNearestNeighborParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteResizeNearestNeighborParams>())).align_corners as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteResizeNearestNeighborParams),
            "::",
            stringify!(align_corners)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteResizeNearestNeighborParams>())).half_pixel_centers
                as *const _ as usize
        },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteResizeNearestNeighborParams),
            "::",
            stringify!(half_pixel_centers)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLitePadParams {
    pub placeholder: EmptyStructPlaceholder,
}
#[test]
fn bindgen_test_layout_TfLitePadParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLitePadParams>(),
        1usize,
        concat!("Size of: ", stringify!(TfLitePadParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLitePadParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLitePadParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePadParams>())).placeholder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePadParams),
            "::",
            stringify!(placeholder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLitePadV2Params {
    pub placeholder: EmptyStructPlaceholder,
}
#[test]
fn bindgen_test_layout_TfLitePadV2Params() {
    assert_eq!(
        ::std::mem::size_of::<TfLitePadV2Params>(),
        1usize,
        concat!("Size of: ", stringify!(TfLitePadV2Params))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLitePadV2Params>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLitePadV2Params))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePadV2Params>())).placeholder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePadV2Params),
            "::",
            stringify!(placeholder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteReshapeParams {
    pub shape: [::std::os::raw::c_int; 8usize],
    pub num_dimensions: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteReshapeParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteReshapeParams>(),
        36usize,
        concat!("Size of: ", stringify!(TfLiteReshapeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteReshapeParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteReshapeParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteReshapeParams>())).shape as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteReshapeParams),
            "::",
            stringify!(shape)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteReshapeParams>())).num_dimensions as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteReshapeParams),
            "::",
            stringify!(num_dimensions)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSkipGramParams {
    pub ngram_size: ::std::os::raw::c_int,
    pub max_skip_size: ::std::os::raw::c_int,
    pub include_all_ngrams: bool,
}
#[test]
fn bindgen_test_layout_TfLiteSkipGramParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSkipGramParams>(),
        12usize,
        concat!("Size of: ", stringify!(TfLiteSkipGramParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSkipGramParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteSkipGramParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSkipGramParams>())).ngram_size as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSkipGramParams),
            "::",
            stringify!(ngram_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSkipGramParams>())).max_skip_size as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSkipGramParams),
            "::",
            stringify!(max_skip_size)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSkipGramParams>())).include_all_ngrams as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSkipGramParams),
            "::",
            stringify!(include_all_ngrams)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSpaceToDepthParams {
    pub block_size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteSpaceToDepthParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSpaceToDepthParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteSpaceToDepthParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSpaceToDepthParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteSpaceToDepthParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSpaceToDepthParams>())).block_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSpaceToDepthParams),
            "::",
            stringify!(block_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteDepthToSpaceParams {
    pub block_size: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteDepthToSpaceParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteDepthToSpaceParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteDepthToSpaceParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteDepthToSpaceParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteDepthToSpaceParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteDepthToSpaceParams>())).block_size as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteDepthToSpaceParams),
            "::",
            stringify!(block_size)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteCastParams {
    pub in_data_type: TfLiteType::Type,
    pub out_data_type: TfLiteType::Type,
}
#[test]
fn bindgen_test_layout_TfLiteCastParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteCastParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteCastParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteCastParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteCastParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteCastParams>())).in_data_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteCastParams),
            "::",
            stringify!(in_data_type)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteCastParams>())).out_data_type as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteCastParams),
            "::",
            stringify!(out_data_type)
        )
    );
}
pub mod TfLiteCombinerType {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteCombinerTypeSum: Type = 0;
    pub const kTfLiteCombinerTypeMean: Type = 1;
    pub const kTfLiteCombinerTypeSqrtn: Type = 2;
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteEmbeddingLookupSparseParams {
    pub combiner: TfLiteCombinerType::Type,
}
#[test]
fn bindgen_test_layout_TfLiteEmbeddingLookupSparseParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteEmbeddingLookupSparseParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteEmbeddingLookupSparseParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteEmbeddingLookupSparseParams>(),
        4usize,
        concat!(
            "Alignment of ",
            stringify!(TfLiteEmbeddingLookupSparseParams)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteEmbeddingLookupSparseParams>())).combiner as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteEmbeddingLookupSparseParams),
            "::",
            stringify!(combiner)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteGatherParams {
    pub axis: ::std::os::raw::c_int,
    pub batch_dims: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteGatherParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteGatherParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteGatherParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteGatherParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteGatherParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteGatherParams>())).axis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteGatherParams),
            "::",
            stringify!(axis)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteGatherParams>())).batch_dims as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteGatherParams),
            "::",
            stringify!(batch_dims)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteTransposeParams {
    pub placeholder: EmptyStructPlaceholder,
}
#[test]
fn bindgen_test_layout_TfLiteTransposeParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteTransposeParams>(),
        1usize,
        concat!("Size of: ", stringify!(TfLiteTransposeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteTransposeParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteTransposeParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteTransposeParams>())).placeholder as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTransposeParams),
            "::",
            stringify!(placeholder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteReducerParams {
    pub keep_dims: bool,
}
#[test]
fn bindgen_test_layout_TfLiteReducerParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteReducerParams>(),
        1usize,
        concat!("Size of: ", stringify!(TfLiteReducerParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteReducerParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteReducerParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteReducerParams>())).keep_dims as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteReducerParams),
            "::",
            stringify!(keep_dims)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSplitParams {
    pub num_splits: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteSplitParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSplitParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteSplitParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSplitParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteSplitParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSplitParams>())).num_splits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSplitParams),
            "::",
            stringify!(num_splits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSplitVParams {
    pub num_splits: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteSplitVParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSplitVParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteSplitVParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSplitVParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteSplitVParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteSplitVParams>())).num_splits as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSplitVParams),
            "::",
            stringify!(num_splits)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSqueezeParams {
    pub squeeze_dims: [::std::os::raw::c_int; 8usize],
    pub num_squeeze_dims: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteSqueezeParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSqueezeParams>(),
        36usize,
        concat!("Size of: ", stringify!(TfLiteSqueezeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSqueezeParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteSqueezeParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSqueezeParams>())).squeeze_dims as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSqueezeParams),
            "::",
            stringify!(squeeze_dims)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSqueezeParams>())).num_squeeze_dims as *const _ as usize
        },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSqueezeParams),
            "::",
            stringify!(num_squeeze_dims)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteStridedSliceParams {
    pub begin_mask: ::std::os::raw::c_int,
    pub end_mask: ::std::os::raw::c_int,
    pub ellipsis_mask: ::std::os::raw::c_int,
    pub new_axis_mask: ::std::os::raw::c_int,
    pub shrink_axis_mask: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteStridedSliceParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteStridedSliceParams>(),
        20usize,
        concat!("Size of: ", stringify!(TfLiteStridedSliceParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteStridedSliceParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteStridedSliceParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteStridedSliceParams>())).begin_mask as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteStridedSliceParams),
            "::",
            stringify!(begin_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteStridedSliceParams>())).end_mask as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteStridedSliceParams),
            "::",
            stringify!(end_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteStridedSliceParams>())).ellipsis_mask as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteStridedSliceParams),
            "::",
            stringify!(ellipsis_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteStridedSliceParams>())).new_axis_mask as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteStridedSliceParams),
            "::",
            stringify!(new_axis_mask)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteStridedSliceParams>())).shrink_axis_mask as *const _
                as usize
        },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteStridedSliceParams),
            "::",
            stringify!(shrink_axis_mask)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteArgMaxParams {
    pub output_type: TfLiteType::Type,
}
#[test]
fn bindgen_test_layout_TfLiteArgMaxParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteArgMaxParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteArgMaxParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteArgMaxParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteArgMaxParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteArgMaxParams>())).output_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteArgMaxParams),
            "::",
            stringify!(output_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteArgMinParams {
    pub output_type: TfLiteType::Type,
}
#[test]
fn bindgen_test_layout_TfLiteArgMinParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteArgMinParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteArgMinParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteArgMinParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteArgMinParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteArgMinParams>())).output_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteArgMinParams),
            "::",
            stringify!(output_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteTransposeConvParams {
    pub padding: TfLitePadding::Type,
    pub stride_width: ::std::os::raw::c_int,
    pub stride_height: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteTransposeConvParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteTransposeConvParams>(),
        12usize,
        concat!("Size of: ", stringify!(TfLiteTransposeConvParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteTransposeConvParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteTransposeConvParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteTransposeConvParams>())).padding as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTransposeConvParams),
            "::",
            stringify!(padding)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteTransposeConvParams>())).stride_width as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTransposeConvParams),
            "::",
            stringify!(stride_width)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteTransposeConvParams>())).stride_height as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteTransposeConvParams),
            "::",
            stringify!(stride_height)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteSparseToDenseParams {
    pub validate_indices: bool,
}
#[test]
fn bindgen_test_layout_TfLiteSparseToDenseParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteSparseToDenseParams>(),
        1usize,
        concat!("Size of: ", stringify!(TfLiteSparseToDenseParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteSparseToDenseParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteSparseToDenseParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteSparseToDenseParams>())).validate_indices as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteSparseToDenseParams),
            "::",
            stringify!(validate_indices)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteShapeParams {
    pub out_type: TfLiteType::Type,
}
#[test]
fn bindgen_test_layout_TfLiteShapeParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteShapeParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteShapeParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteShapeParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteShapeParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteShapeParams>())).out_type as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteShapeParams),
            "::",
            stringify!(out_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteRankParams {
    pub placeholder: EmptyStructPlaceholder,
}
#[test]
fn bindgen_test_layout_TfLiteRankParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteRankParams>(),
        1usize,
        concat!("Size of: ", stringify!(TfLiteRankParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteRankParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteRankParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteRankParams>())).placeholder as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteRankParams),
            "::",
            stringify!(placeholder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteFakeQuantParams {
    pub min: f32,
    pub max: f32,
    pub num_bits: ::std::os::raw::c_int,
    pub narrow_range: bool,
}
#[test]
fn bindgen_test_layout_TfLiteFakeQuantParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteFakeQuantParams>(),
        16usize,
        concat!("Size of: ", stringify!(TfLiteFakeQuantParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteFakeQuantParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteFakeQuantParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteFakeQuantParams>())).min as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFakeQuantParams),
            "::",
            stringify!(min)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteFakeQuantParams>())).max as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFakeQuantParams),
            "::",
            stringify!(max)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteFakeQuantParams>())).num_bits as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFakeQuantParams),
            "::",
            stringify!(num_bits)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteFakeQuantParams>())).narrow_range as *const _ as usize
        },
        12usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteFakeQuantParams),
            "::",
            stringify!(narrow_range)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLitePackParams {
    pub values_count: ::std::os::raw::c_int,
    pub axis: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLitePackParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLitePackParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLitePackParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLitePackParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLitePackParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePackParams>())).values_count as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePackParams),
            "::",
            stringify!(values_count)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLitePackParams>())).axis as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLitePackParams),
            "::",
            stringify!(axis)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteOneHotParams {
    pub axis: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteOneHotParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteOneHotParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteOneHotParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteOneHotParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteOneHotParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteOneHotParams>())).axis as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteOneHotParams),
            "::",
            stringify!(axis)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteUnpackParams {
    pub num: ::std::os::raw::c_int,
    pub axis: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteUnpackParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteUnpackParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteUnpackParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteUnpackParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteUnpackParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteUnpackParams>())).num as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteUnpackParams),
            "::",
            stringify!(num)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteUnpackParams>())).axis as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteUnpackParams),
            "::",
            stringify!(axis)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteLeakyReluParams {
    pub alpha: f32,
}
#[test]
fn bindgen_test_layout_TfLiteLeakyReluParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteLeakyReluParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteLeakyReluParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteLeakyReluParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteLeakyReluParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteLeakyReluParams>())).alpha as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteLeakyReluParams),
            "::",
            stringify!(alpha)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteUniqueParams {
    pub index_out_type: TfLiteType::Type,
}
#[test]
fn bindgen_test_layout_TfLiteUniqueParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteUniqueParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteUniqueParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteUniqueParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteUniqueParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteUniqueParams>())).index_out_type as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteUniqueParams),
            "::",
            stringify!(index_out_type)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteReverseSequenceParams {
    pub seq_dim: ::std::os::raw::c_int,
    pub batch_dim: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteReverseSequenceParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteReverseSequenceParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteReverseSequenceParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteReverseSequenceParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteReverseSequenceParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteReverseSequenceParams>())).seq_dim as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteReverseSequenceParams),
            "::",
            stringify!(seq_dim)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteReverseSequenceParams>())).batch_dim as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteReverseSequenceParams),
            "::",
            stringify!(batch_dim)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteMatrixDiagParams {
    pub placeholder: EmptyStructPlaceholder,
}
#[test]
fn bindgen_test_layout_TfLiteMatrixDiagParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteMatrixDiagParams>(),
        1usize,
        concat!("Size of: ", stringify!(TfLiteMatrixDiagParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteMatrixDiagParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteMatrixDiagParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteMatrixDiagParams>())).placeholder as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteMatrixDiagParams),
            "::",
            stringify!(placeholder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteMatrixSetDiagParams {
    pub placeholder: EmptyStructPlaceholder,
}
#[test]
fn bindgen_test_layout_TfLiteMatrixSetDiagParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteMatrixSetDiagParams>(),
        1usize,
        concat!("Size of: ", stringify!(TfLiteMatrixSetDiagParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteMatrixSetDiagParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteMatrixSetDiagParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteMatrixSetDiagParams>())).placeholder as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteMatrixSetDiagParams),
            "::",
            stringify!(placeholder)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteIfParams {
    pub then_subgraph_index: ::std::os::raw::c_int,
    pub else_subgraph_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteIfParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteIfParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteIfParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteIfParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteIfParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteIfParams>())).then_subgraph_index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteIfParams),
            "::",
            stringify!(then_subgraph_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteIfParams>())).else_subgraph_index as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteIfParams),
            "::",
            stringify!(else_subgraph_index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteWhileParams {
    pub cond_subgraph_index: ::std::os::raw::c_int,
    pub body_subgraph_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteWhileParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteWhileParams>(),
        8usize,
        concat!("Size of: ", stringify!(TfLiteWhileParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteWhileParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteWhileParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteWhileParams>())).cond_subgraph_index as *const _ as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteWhileParams),
            "::",
            stringify!(cond_subgraph_index)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteWhileParams>())).body_subgraph_index as *const _ as usize
        },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteWhileParams),
            "::",
            stringify!(body_subgraph_index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteCumsumParams {
    pub exclusive: bool,
    pub reverse: bool,
}
#[test]
fn bindgen_test_layout_TfLiteCumsumParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteCumsumParams>(),
        2usize,
        concat!("Size of: ", stringify!(TfLiteCumsumParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteCumsumParams>(),
        1usize,
        concat!("Alignment of ", stringify!(TfLiteCumsumParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteCumsumParams>())).exclusive as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteCumsumParams),
            "::",
            stringify!(exclusive)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteCumsumParams>())).reverse as *const _ as usize },
        1usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteCumsumParams),
            "::",
            stringify!(reverse)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteCallOnceParams {
    pub init_subgraph_index: ::std::os::raw::c_int,
}
#[test]
fn bindgen_test_layout_TfLiteCallOnceParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteCallOnceParams>(),
        4usize,
        concat!("Size of: ", stringify!(TfLiteCallOnceParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteCallOnceParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteCallOnceParams))
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteCallOnceParams>())).init_subgraph_index as *const _
                as usize
        },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteCallOnceParams),
            "::",
            stringify!(init_subgraph_index)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteHashtableParams {
    pub table_id: ::std::os::raw::c_int,
    pub key_dtype: TfLiteType::Type,
    pub value_dtype: TfLiteType::Type,
}
#[test]
fn bindgen_test_layout_TfLiteHashtableParams() {
    assert_eq!(
        ::std::mem::size_of::<TfLiteHashtableParams>(),
        12usize,
        concat!("Size of: ", stringify!(TfLiteHashtableParams))
    );
    assert_eq!(
        ::std::mem::align_of::<TfLiteHashtableParams>(),
        4usize,
        concat!("Alignment of ", stringify!(TfLiteHashtableParams))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteHashtableParams>())).table_id as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteHashtableParams),
            "::",
            stringify!(table_id)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<TfLiteHashtableParams>())).key_dtype as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteHashtableParams),
            "::",
            stringify!(key_dtype)
        )
    );
    assert_eq!(
        unsafe {
            &(*(::std::ptr::null::<TfLiteHashtableParams>())).value_dtype as *const _ as usize
        },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(TfLiteHashtableParams),
            "::",
            stringify!(value_dtype)
        )
    );
}
pub type va_list = __builtin_va_list;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteModel {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteInterpreterOptions {
    _unused: [u8; 0],
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct TfLiteInterpreter {
    _unused: [u8; 0],
}
extern "C" {
    pub fn TfLiteVersion() -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TfLiteModelCreate(
        model_data: *const ::std::os::raw::c_void,
        model_size: usize,
    ) -> *mut TfLiteModel;
}
extern "C" {
    pub fn TfLiteModelCreateFromFile(model_path: *const ::std::os::raw::c_char)
        -> *mut TfLiteModel;
}
extern "C" {
    pub fn TfLiteModelDelete(model: *mut TfLiteModel);
}
extern "C" {
    pub fn TfLiteInterpreterOptionsCreate() -> *mut TfLiteInterpreterOptions;
}
extern "C" {
    pub fn TfLiteInterpreterOptionsDelete(options: *mut TfLiteInterpreterOptions);
}
extern "C" {
    pub fn TfLiteInterpreterOptionsSetNumThreads(
        options: *mut TfLiteInterpreterOptions,
        num_threads: i32,
    );
}
extern "C" {
    pub fn TfLiteInterpreterOptionsAddDelegate(
        options: *mut TfLiteInterpreterOptions,
        delegate: *mut TfLiteDelegate,
    );
}
extern "C" {
    pub fn TfLiteInterpreterOptionsSetErrorReporter(
        options: *mut TfLiteInterpreterOptions,
        reporter: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                format: *const ::std::os::raw::c_char,
                args: *mut __va_list_tag,
            ),
        >,
        user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    pub fn TfLiteInterpreterCreate(
        model: *const TfLiteModel,
        optional_options: *const TfLiteInterpreterOptions,
    ) -> *mut TfLiteInterpreter;
}
extern "C" {
    pub fn TfLiteInterpreterDelete(interpreter: *mut TfLiteInterpreter);
}
extern "C" {
    pub fn TfLiteInterpreterGetInputTensorCount(interpreter: *const TfLiteInterpreter) -> i32;
}
extern "C" {
    pub fn TfLiteInterpreterGetInputTensor(
        interpreter: *const TfLiteInterpreter,
        input_index: i32,
    ) -> *mut TfLiteTensor;
}
extern "C" {
    pub fn TfLiteInterpreterResizeInputTensor(
        interpreter: *mut TfLiteInterpreter,
        input_index: i32,
        input_dims: *const ::std::os::raw::c_int,
        input_dims_size: i32,
    ) -> TfLiteStatus::Type;
}
extern "C" {
    pub fn TfLiteInterpreterAllocateTensors(
        interpreter: *mut TfLiteInterpreter,
    ) -> TfLiteStatus::Type;
}
extern "C" {
    pub fn TfLiteInterpreterInvoke(interpreter: *mut TfLiteInterpreter) -> TfLiteStatus::Type;
}
extern "C" {
    pub fn TfLiteInterpreterGetOutputTensorCount(interpreter: *const TfLiteInterpreter) -> i32;
}
extern "C" {
    pub fn TfLiteInterpreterGetOutputTensor(
        interpreter: *const TfLiteInterpreter,
        output_index: i32,
    ) -> *const TfLiteTensor;
}
extern "C" {
    pub fn TfLiteTensorType(tensor: *const TfLiteTensor) -> TfLiteType::Type;
}
extern "C" {
    pub fn TfLiteTensorNumDims(tensor: *const TfLiteTensor) -> i32;
}
extern "C" {
    pub fn TfLiteTensorDim(tensor: *const TfLiteTensor, dim_index: i32) -> i32;
}
extern "C" {
    pub fn TfLiteTensorByteSize(tensor: *const TfLiteTensor) -> usize;
}
extern "C" {
    pub fn TfLiteTensorData(tensor: *const TfLiteTensor) -> *mut ::std::os::raw::c_void;
}
extern "C" {
    pub fn TfLiteTensorName(tensor: *const TfLiteTensor) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn TfLiteTensorQuantizationParams(tensor: *const TfLiteTensor) -> TfLiteQuantizationParams;
}
extern "C" {
    pub fn TfLiteTensorCopyFromBuffer(
        tensor: *mut TfLiteTensor,
        input_data: *const ::std::os::raw::c_void,
        input_data_size: usize,
    ) -> TfLiteStatus::Type;
}
extern "C" {
    pub fn TfLiteTensorCopyToBuffer(
        output_tensor: *const TfLiteTensor,
        output_data: *mut ::std::os::raw::c_void,
        output_data_size: usize,
    ) -> TfLiteStatus::Type;
}
pub mod TfLiteBuiltinOperator {
    pub type Type = ::std::os::raw::c_uint;
    pub const kTfLiteBuiltinAdd: Type = 0;
    pub const kTfLiteBuiltinAveragePool2d: Type = 1;
    pub const kTfLiteBuiltinConcatenation: Type = 2;
    pub const kTfLiteBuiltinConv2d: Type = 3;
    pub const kTfLiteBuiltinDepthwiseConv2d: Type = 4;
    pub const kTfLiteBuiltinDepthToSpace: Type = 5;
    pub const kTfLiteBuiltinDequantize: Type = 6;
    pub const kTfLiteBuiltinEmbeddingLookup: Type = 7;
    pub const kTfLiteBuiltinFloor: Type = 8;
    pub const kTfLiteBuiltinFullyConnected: Type = 9;
    pub const kTfLiteBuiltinHashtableLookup: Type = 10;
    pub const kTfLiteBuiltinL2Normalization: Type = 11;
    pub const kTfLiteBuiltinL2Pool2d: Type = 12;
    pub const kTfLiteBuiltinLocalResponseNormalization: Type = 13;
    pub const kTfLiteBuiltinLogistic: Type = 14;
    pub const kTfLiteBuiltinLshProjection: Type = 15;
    pub const kTfLiteBuiltinLstm: Type = 16;
    pub const kTfLiteBuiltinMaxPool2d: Type = 17;
    pub const kTfLiteBuiltinMul: Type = 18;
    pub const kTfLiteBuiltinRelu: Type = 19;
    pub const kTfLiteBuiltinReluN1To1: Type = 20;
    pub const kTfLiteBuiltinRelu6: Type = 21;
    pub const kTfLiteBuiltinReshape: Type = 22;
    pub const kTfLiteBuiltinResizeBilinear: Type = 23;
    pub const kTfLiteBuiltinRnn: Type = 24;
    pub const kTfLiteBuiltinSoftmax: Type = 25;
    pub const kTfLiteBuiltinSpaceToDepth: Type = 26;
    pub const kTfLiteBuiltinSvdf: Type = 27;
    pub const kTfLiteBuiltinTanh: Type = 28;
    pub const kTfLiteBuiltinConcatEmbeddings: Type = 29;
    pub const kTfLiteBuiltinSkipGram: Type = 30;
    pub const kTfLiteBuiltinCall: Type = 31;
    pub const kTfLiteBuiltinCustom: Type = 32;
    pub const kTfLiteBuiltinEmbeddingLookupSparse: Type = 33;
    pub const kTfLiteBuiltinPad: Type = 34;
    pub const kTfLiteBuiltinUnidirectionalSequenceRnn: Type = 35;
    pub const kTfLiteBuiltinGather: Type = 36;
    pub const kTfLiteBuiltinBatchToSpaceNd: Type = 37;
    pub const kTfLiteBuiltinSpaceToBatchNd: Type = 38;
    pub const kTfLiteBuiltinTranspose: Type = 39;
    pub const kTfLiteBuiltinMean: Type = 40;
    pub const kTfLiteBuiltinSub: Type = 41;
    pub const kTfLiteBuiltinDiv: Type = 42;
    pub const kTfLiteBuiltinSqueeze: Type = 43;
    pub const kTfLiteBuiltinUnidirectionalSequenceLstm: Type = 44;
    pub const kTfLiteBuiltinStridedSlice: Type = 45;
    pub const kTfLiteBuiltinBidirectionalSequenceRnn: Type = 46;
    pub const kTfLiteBuiltinExp: Type = 47;
    pub const kTfLiteBuiltinTopkV2: Type = 48;
    pub const kTfLiteBuiltinSplit: Type = 49;
    pub const kTfLiteBuiltinLogSoftmax: Type = 50;
    pub const kTfLiteBuiltinDelegate: Type = 51;
    pub const kTfLiteBuiltinBidirectionalSequenceLstm: Type = 52;
    pub const kTfLiteBuiltinCast: Type = 53;
    pub const kTfLiteBuiltinPrelu: Type = 54;
    pub const kTfLiteBuiltinMaximum: Type = 55;
    pub const kTfLiteBuiltinArgMax: Type = 56;
    pub const kTfLiteBuiltinMinimum: Type = 57;
    pub const kTfLiteBuiltinLess: Type = 58;
    pub const kTfLiteBuiltinNeg: Type = 59;
    pub const kTfLiteBuiltinPadv2: Type = 60;
    pub const kTfLiteBuiltinGreater: Type = 61;
    pub const kTfLiteBuiltinGreaterEqual: Type = 62;
    pub const kTfLiteBuiltinLessEqual: Type = 63;
    pub const kTfLiteBuiltinSelect: Type = 64;
    pub const kTfLiteBuiltinSlice: Type = 65;
    pub const kTfLiteBuiltinSin: Type = 66;
    pub const kTfLiteBuiltinTransposeConv: Type = 67;
    pub const kTfLiteBuiltinSparseToDense: Type = 68;
    pub const kTfLiteBuiltinTile: Type = 69;
    pub const kTfLiteBuiltinExpandDims: Type = 70;
    pub const kTfLiteBuiltinEqual: Type = 71;
    pub const kTfLiteBuiltinNotEqual: Type = 72;
    pub const kTfLiteBuiltinLog: Type = 73;
    pub const kTfLiteBuiltinSum: Type = 74;
    pub const kTfLiteBuiltinSqrt: Type = 75;
    pub const kTfLiteBuiltinRsqrt: Type = 76;
    pub const kTfLiteBuiltinShape: Type = 77;
    pub const kTfLiteBuiltinPow: Type = 78;
    pub const kTfLiteBuiltinArgMin: Type = 79;
    pub const kTfLiteBuiltinFakeQuant: Type = 80;
    pub const kTfLiteBuiltinReduceProd: Type = 81;
    pub const kTfLiteBuiltinReduceMax: Type = 82;
    pub const kTfLiteBuiltinPack: Type = 83;
    pub const kTfLiteBuiltinLogicalOr: Type = 84;
    pub const kTfLiteBuiltinOneHot: Type = 85;
    pub const kTfLiteBuiltinLogicalAnd: Type = 86;
    pub const kTfLiteBuiltinLogicalNot: Type = 87;
    pub const kTfLiteBuiltinUnpack: Type = 88;
    pub const kTfLiteBuiltinReduceMin: Type = 89;
    pub const kTfLiteBuiltinFloorDiv: Type = 90;
    pub const kTfLiteBuiltinReduceAny: Type = 91;
    pub const kTfLiteBuiltinSquare: Type = 92;
    pub const kTfLiteBuiltinZerosLike: Type = 93;
    pub const kTfLiteBuiltinFill: Type = 94;
    pub const kTfLiteBuiltinFloorMod: Type = 95;
    pub const kTfLiteBuiltinRange: Type = 96;
    pub const kTfLiteBuiltinResizeNearestNeighbor: Type = 97;
    pub const kTfLiteBuiltinLeakyRelu: Type = 98;
    pub const kTfLiteBuiltinSquaredDifference: Type = 99;
    pub const kTfLiteBuiltinMirrorPad: Type = 100;
    pub const kTfLiteBuiltinAbs: Type = 101;
    pub const kTfLiteBuiltinSplitV: Type = 102;
    pub const kTfLiteBuiltinUnique: Type = 103;
    pub const kTfLiteBuiltinCeil: Type = 104;
    pub const kTfLiteBuiltinReverseV2: Type = 105;
    pub const kTfLiteBuiltinAddN: Type = 106;
    pub const kTfLiteBuiltinGatherNd: Type = 107;
    pub const kTfLiteBuiltinCos: Type = 108;
    pub const kTfLiteBuiltinWhere: Type = 109;
    pub const kTfLiteBuiltinRank: Type = 110;
    pub const kTfLiteBuiltinElu: Type = 111;
    pub const kTfLiteBuiltinReverseSequence: Type = 112;
    pub const kTfLiteBuiltinMatrixDiag: Type = 113;
    pub const kTfLiteBuiltinQuantize: Type = 114;
    pub const kTfLiteBuiltinMatrixSetDiag: Type = 115;
    pub const kTfLiteBuiltinRound: Type = 116;
    pub const kTfLiteBuiltinHardSwish: Type = 117;
    pub const kTfLiteBuiltinIf: Type = 118;
    pub const kTfLiteBuiltinWhile: Type = 119;
    pub const kTfLiteBuiltinNonMaxSuppressionV4: Type = 120;
    pub const kTfLiteBuiltinNonMaxSuppressionV5: Type = 121;
    pub const kTfLiteBuiltinScatterNd: Type = 122;
    pub const kTfLiteBuiltinSelectV2: Type = 123;
    pub const kTfLiteBuiltinDensify: Type = 124;
    pub const kTfLiteBuiltinSegmentSum: Type = 125;
    pub const kTfLiteBuiltinBatchMatmul: Type = 126;
    pub const kTfLiteBuiltinPlaceholderForGreaterOpCodes: Type = 127;
    pub const kTfLiteBuiltinCumsum: Type = 128;
    pub const kTfLiteBuiltinCallOnce: Type = 129;
    pub const kTfLiteBuiltinBroadcastTo: Type = 130;
    pub const kTfLiteBuiltinRfft2d: Type = 131;
    pub const kTfLiteBuiltinConv3d: Type = 132;
    pub const kTfLiteBuiltinImag: Type = 133;
    pub const kTfLiteBuiltinReal: Type = 134;
    pub const kTfLiteBuiltinComplexAbs: Type = 135;
    pub const kTfLiteBuiltinHashtable: Type = 136;
    pub const kTfLiteBuiltinHashtableFind: Type = 137;
    pub const kTfLiteBuiltinHashtableImport: Type = 138;
    pub const kTfLiteBuiltinHashtableSize: Type = 139;
}
extern "C" {
    #[doc = " Resets all variable tensors to zero."]
    #[doc = ""]
    #[doc = " WARNING: This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterResetVariableTensors(
        interpreter: *mut TfLiteInterpreter,
    ) -> TfLiteStatus::Type;
}
extern "C" {
    #[doc = " Adds an op registration for a builtin operator."]
    #[doc = ""]
    #[doc = " Op registrations are used to map ops referenced in the flatbuffer model"]
    #[doc = " to executable function pointers (`TfLiteRegistration`s)."]
    #[doc = ""]
    #[doc = " NOTE: The interpreter will make a shallow copy of `registration` internally,"]
    #[doc = " so the caller should ensure that its contents (function pointers, etc...)"]
    #[doc = " remain valid for the duration of the interpreter's lifetime. A common"]
    #[doc = " practice is making the provided `TfLiteRegistration` instance static."]
    #[doc = ""]
    #[doc = " Code that uses this function should NOT call"]
    #[doc = " `TfLiteInterpreterOptionsSetOpResolver' on the same options object."]
    #[doc = ""]
    #[doc = " WARNING: This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterOptionsAddBuiltinOp(
        options: *mut TfLiteInterpreterOptions,
        op: TfLiteBuiltinOperator::Type,
        registration: *const TfLiteRegistration,
        min_version: i32,
        max_version: i32,
    );
}
extern "C" {
    #[doc = " Adds an op registration for a custom operator."]
    #[doc = ""]
    #[doc = " Op registrations are used to map ops referenced in the flatbuffer model"]
    #[doc = " to executable function pointers (`TfLiteRegistration`s)."]
    #[doc = ""]
    #[doc = " NOTE: The interpreter will make a shallow copy of `registration` internally,"]
    #[doc = " so the caller should ensure that its contents (function pointers, etc...)"]
    #[doc = " remain valid for the duration of any created interpreter's lifetime. A"]
    #[doc = " common practice is making the provided `TfLiteRegistration` instance static."]
    #[doc = ""]
    #[doc = " Code that uses this function should NOT call"]
    #[doc = " `TfLiteInterpreterOptionsSetOpResolver' on the same options object."]
    #[doc = ""]
    #[doc = " WARNING: This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterOptionsAddCustomOp(
        options: *mut TfLiteInterpreterOptions,
        name: *const ::std::os::raw::c_char,
        registration: *const TfLiteRegistration,
        min_version: i32,
        max_version: i32,
    );
}
extern "C" {
    #[doc = " Registers callbacks for resolving builtin or custom operators."]
    #[doc = ""]
    #[doc = " The `TfLiteInterpreterOptionsSetOpResolver` function provides an alternative"]
    #[doc = " method for registering builtin ops and/or custom ops, by providing operator"]
    #[doc = " resolver callbacks.  Unlike using `TfLiteInterpreterOptionsAddBuiltinOp`"]
    #[doc = " and/or `TfLiteInterpreterOptionsAddAddCustomOp`, these let you register all"]
    #[doc = " the operators in a single call."]
    #[doc = ""]
    #[doc = " Code that uses this function should NOT call"]
    #[doc = " `TfLiteInterpreterOptionsAddBuiltin' or"]
    #[doc = " `TfLiteInterpreterOptionsAddCustomOp' on the same options object."]
    #[doc = ""]
    #[doc = " WARNING: This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterOptionsSetOpResolver(
        options: *mut TfLiteInterpreterOptions,
        find_builtin_op: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                op: TfLiteBuiltinOperator::Type,
                version: ::std::os::raw::c_int,
            ) -> *const TfLiteRegistration,
        >,
        find_custom_op: ::std::option::Option<
            unsafe extern "C" fn(
                user_data: *mut ::std::os::raw::c_void,
                custom_op: *const ::std::os::raw::c_char,
                version: ::std::os::raw::c_int,
            ) -> *const TfLiteRegistration,
        >,
        op_resolver_user_data: *mut ::std::os::raw::c_void,
    );
}
extern "C" {
    #[doc = " Returns a new interpreter using the provided model and options, or null on"]
    #[doc = " failure, where the model uses only the operators explicitly added to the"]
    #[doc = " options.  This is the same as `TFLiteInterpreterCreate` from `c_api.h`,"]
    #[doc = " except that the only operators that are supported are the ones registered"]
    #[doc = " in `options` via calls to `TfLiteInterpreterOptionsSetOpResolver`,"]
    #[doc = " `TfLiteInterpreterOptionsAddBuiltinOp`, and/or"]
    #[doc = " `TfLiteInterpreterOptionsAddCustomOp`."]
    #[doc = ""]
    #[doc = " * `model` must be a valid model instance. The caller retains ownership of"]
    #[doc = "   the object, and can destroy it immediately after creating the interpreter;"]
    #[doc = "   the interpreter will maintain its own reference to the underlying model"]
    #[doc = "   data."]
    #[doc = " * `options` should not be null. The caller retains ownership of the object,"]
    #[doc = "   and can safely destroy it immediately after creating the interpreter."]
    #[doc = ""]
    #[doc = " NOTE: The client *must* explicitly allocate tensors before attempting to"]
    #[doc = " access input tensor data or invoke the interpreter."]
    #[doc = ""]
    #[doc = " WARNING: This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterCreateWithSelectedOps(
        model: *const TfLiteModel,
        options: *const TfLiteInterpreterOptions,
    ) -> *mut TfLiteInterpreter;
}
extern "C" {
    #[doc = " Enable or disable the NN API delegate for the interpreter (true to enable)."]
    #[doc = ""]
    #[doc = " WARNING: This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterOptionsSetUseNNAPI(
        options: *mut TfLiteInterpreterOptions,
        enable: bool,
    );
}
extern "C" {
    #[doc = " Enable or disable CPU fallback for the interpreter (true to enable)."]
    #[doc = " If enabled, TfLiteInterpreterInvoke will do automatic fallback from"]
    #[doc = " executing with delegate(s) to regular execution without delegates"]
    #[doc = " (i.e. on CPU)."]
    #[doc = ""]
    #[doc = " Allowing the fallback is suitable only if both of the following hold:"]
    #[doc = " - The caller is known not to cache pointers to tensor data across"]
    #[doc = "   TfLiteInterpreterInvoke calls."]
    #[doc = " - The model is not stateful (no variables, no LSTMs) or the state isn't"]
    #[doc = "   needed between batches."]
    #[doc = ""]
    #[doc = " When delegate fallback is enabled, TfLiteInterpreterInvoke will"]
    #[doc = " behave as follows:"]
    #[doc = "   If one or more delegates were set in the interpreter options"]
    #[doc = "   (see TfLiteInterpreterOptionsAddDelegate),"]
    #[doc = "   AND inference fails,"]
    #[doc = "   then the interpreter will fall back to not using any delegates."]
    #[doc = "   In that case, the previously applied delegate(s) will be automatically"]
    #[doc = "   undone, and an attempt will be made to return the interpreter to an"]
    #[doc = "   invokable state, which may invalidate previous tensor addresses,"]
    #[doc = "   and the inference will be attempted again, using input tensors with"]
    #[doc = "   the same value as previously set."]
    #[doc = ""]
    #[doc = " WARNING: This is an experimental API and subject to change."]
    pub fn TfLiteInterpreterOptionsSetEnableDelegateFallback(
        options: *mut TfLiteInterpreterOptions,
        enable: bool,
    );
}
pub type __builtin_va_list = [__va_list_tag; 1usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __va_list_tag {
    pub gp_offset: ::std::os::raw::c_uint,
    pub fp_offset: ::std::os::raw::c_uint,
    pub overflow_arg_area: *mut ::std::os::raw::c_void,
    pub reg_save_area: *mut ::std::os::raw::c_void,
}
#[test]
fn bindgen_test_layout___va_list_tag() {
    assert_eq!(
        ::std::mem::size_of::<__va_list_tag>(),
        24usize,
        concat!("Size of: ", stringify!(__va_list_tag))
    );
    assert_eq!(
        ::std::mem::align_of::<__va_list_tag>(),
        8usize,
        concat!("Alignment of ", stringify!(__va_list_tag))
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).gp_offset as *const _ as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(gp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).fp_offset as *const _ as usize },
        4usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(fp_offset)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).overflow_arg_area as *const _ as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(overflow_arg_area)
        )
    );
    assert_eq!(
        unsafe { &(*(::std::ptr::null::<__va_list_tag>())).reg_save_area as *const _ as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__va_list_tag),
            "::",
            stringify!(reg_save_area)
        )
    );
}
